<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Survey Bot Demo</title>
    <style>
        /* Global Resets and Base Styles */
        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            margin: 0;
            padding: 0;
            background-color: #f4f6f8; /* Lighter overall background */
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            color: #333;
            height: 100vh;
            overflow: hidden;
            display: flex; /* Ensure body takes full height for chat container */
            flex-direction: column;
        }

        .chat-container { /* This is the main box holding the chat UI */
            width: 100%;
            height: 100%; /* Take full height of its parent (iframe) */
            display: flex;
            flex-direction: column;
            border-radius: 8px;
            overflow: hidden; /* Ensures child elements conform to border-radius */
            box-shadow: 0 4px 12px rgba(0,0,0,0.1); /* Softer, more modern shadow */
            background-color: #ffffff; /* Changed to white for brighter appearance */
        }

        .chat-header {
            background-color: #6c757d; /* Medium grey */
            color: white;
            padding: 15px;
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            border-top-left-radius: 8px; /* Match container */
            border-top-right-radius: 8px; /* Match container */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        /* Chat Log / Messages Area */
        .chat-log {
            background-color: #ffffff; /* Keep it clean white */
            padding: 15px;
            flex-grow: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 12px; /* Space between messages */
        }

        /* Individual Messages */
        .message {
            padding: 10px 15px;
            border-radius: 18px; /* Softer, more modern radius */
            max-width: 75%;
            word-wrap: break-word;
            line-height: 1.5;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
        }

        .user-message {
            background-color: #007bff; /* User messages in primary blue */
            color: white;
            align-self: flex-end;
            margin-left: auto; /* Pushes to the right */
            border-radius: 18px 18px 5px 18px; /* Slightly different shape */
        }

        .bot-message {
            background-color: #f1f3f5; /* Even lighter grey, for better pop */
            color: #212529; /* Dark text for bot */
            align-self: flex-start;
            border-radius: 5px 18px 18px 18px; /* Slightly different shape */
        }

        .message.thinking-message {
            background-color: #e9ecef; /* Match bot message background */
            align-self: flex-start;
            display: flex;
            align-items: center;
            padding: 12px 15px; /* Adjust padding for dots */
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            border-radius: 5px 18px 18px 18px;
        }

        /* Typing Indicator Animation */
        @keyframes bounce_dots {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-8px); }
            60% { transform: translateY(-4px); }
        }

        .thinking-message .dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #888;
            margin: 0 2px;
            animation: bounce_dots 1.4s infinite ease-in-out both;
        }

        .thinking-message .dot:nth-child(1) { animation-delay: -0.32s; }
        .thinking-message .dot:nth-child(2) { animation-delay: -0.16s; }
        .thinking-message .dot:nth-child(3) { animation-delay: 0s; }

        .message.error-message {
            color: #721c24; /* Dark red for text */
            background-color: #f8d7da; /* Light red background */
            border: 1px solid #f5c6cb; /* Red border */
            align-self: flex-start;
            box-shadow: none;
        }

        /* Input Area */
        .input-container {
            background: #ffffff;
            border-top: 1px solid #e0e0e0;
            padding: 10px 15px;
            display: flex;
            align-items: center; /* Vertically align items */
            flex-shrink: 0;
            gap: 10px;
        }

        .chat-input {
            flex-grow: 1;
            padding: 10px 15px;
            border: 1px solid #ced4da;
            border-radius: 20px; /* Pill shape */
            font-size: 1em;
            line-height: 1.4;
            resize: none; /* Prevent manual resize of textarea */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none;  /* IE 10+ */
        }
        .chat-input::-webkit-scrollbar { display: none; } /* WebKit */

        .chat-input:focus {
            outline: none;
            border-color: #80bdff;
            box-shadow: 0 0 0 0.2rem rgba(0,123,255,.25);
        }

        .send-button {
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 8px; /* More of a square with rounded edges */
            padding: 10px 20px; /* Keep padding for text */
            font-size: 1em;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .send-button:hover {
            background-color: #0056b3;
        }

        .send-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            Survey Bot Demo
        </div>
        <div id="chatLog" class="chat-log">
            {% for msg_item in history %}
                {% if msg_item.role == 'user' %}
                    <div class="message user-message">{{ msg_item.parts[0] }}</div>
                {% elif msg_item.role == 'model' %}
                    <div class="message bot-message">{{ msg_item.parts[0] }}</div>
                {% endif %}
            {% endfor %}
        </div>

        <form id="chatForm" method="POST" action="/">
            <div class="input-container">
                <input type="hidden" name="session_id" value="{{ session_id }}">
                <textarea
                    id="chatInput"
                    name="prompt"
                    class="chat-input"
                    placeholder="Type something..."
                    rows="1"
                    aria-label="Chat message input"
                    required
                ></textarea>
                <button class="send-button" type="submit" aria-label="Send message">
                    Send
                </button>
            </div>
        </form>
    </div>

<script>
    // SCRIPT EXECUTION TRACKING
    const SCRIPT_INSTANCE_ID = Date.now() + "_" + Math.random().toString(36).substring(2, 7);
    console.log(`[IFRAME SCRIPT START - Instance ${SCRIPT_INSTANCE_ID}] Timestamp: ${new Date().toISOString()}`);

    // Global state for this iframe instance
    let dynamicQualtricsOrigin = null;
    let chatbotConfig = null;
    let isChatbotInitialized = false; // Tracks if init_chatbot has been successfully processed for THIS instance
    let currentSessionId = "{{ session_id }}"; // From Flask template

    console.log(`[IFRAME - Instance ${SCRIPT_INSTANCE_ID}] Initial state: dynamicQualtricsOrigin=${dynamicQualtricsOrigin}, isChatbotInitialized=${isChatbotInitialized}, currentSessionId=${currentSessionId}`);

    const chatLog = document.getElementById("chatLog");
    const chatInput = document.getElementById("chatInput");
    const chatForm = document.getElementById('chatForm');
    const sendButton = chatForm?.querySelector('button');

    if (chatLog) {
        chatLog.scrollTop = chatLog.scrollHeight;
    }

    function autoResizeTextarea(element) {
        if (!element) return;
        element.style.height = 'auto';
        const newHeight = Math.min(150, Math.max(38, element.scrollHeight)); // Max 150px, Min 38px (approx 1 row)
        element.style.height = newHeight + 'px';
    }

    if (chatInput) {
        chatInput.focus();
        chatInput.addEventListener('input', () => autoResizeTextarea(chatInput));
        autoResizeTextarea(chatInput); // Initial resize

        chatInput.addEventListener('keydown', (event) => {
            if (event.key === "Enter" && !event.shiftKey) {
                event.preventDefault();
                if (chatForm && sendButton && !sendButton.disabled && chatInput.value.trim() !== "") {
                    // Do NOT disable button or input here, as it prevents form submission
                    addMessageToChatLog(chatInput.value.trim(), 'user');
                    addMessageToChatLog('...', 'thinking', 'thinkingIndicator'); 
                    chatForm.submit();
                }
            }
        });
    }

    if (chatForm) {
        chatForm.addEventListener('submit', function(e) {
            // This event listener is primarily for when the form is submitted by means other than Enter key (e.g., clicking Send button)
            // Do NOT disable button or input here, as it prevents form submission
            if (chatInput) {
                if (!chatInput.value.trim()) { // Prevent submission if input is empty on direct submit
                    e.preventDefault();
                    // Re-enable button if submit was prevented (though it shouldn't be disabled by this point)
                    if (sendButton) sendButton.disabled = false;
                    return;
                }
                // If user message wasn't added by Enter key handler (e.g. click on send button), add it now.
                // Check if a message with this exact text already exists as the last user message.
                const userMessages = chatLog.querySelectorAll('.user-message');
                const lastUserMessage = userMessages.length > 0 ? userMessages[userMessages.length - 1] : null;
                if (!lastUserMessage || lastUserMessage.textContent !== chatInput.value.trim()) {
                    addMessageToChatLog(chatInput.value.trim(), 'user');
                }
                addMessageToChatLog('...', 'thinking', 'thinkingIndicator');
            }
        });
    }

    // Helper function to add messages to the chat log
    function addMessageToChatLog(text, role, id = null) {
        if (!chatLog) return null;

        const existingThinking = document.getElementById('thinkingIndicator');
        if (existingThinking && role !== 'thinking') {
            existingThinking.remove();
        }

        const messageDiv = document.createElement('div');
        messageDiv.classList.add('message');
        
        if (role === 'user') {
            messageDiv.classList.add('user-message');
            messageDiv.textContent = text;
            messageDiv.dataset.text = text;
        } else if (role === 'model') {
            messageDiv.classList.add('bot-message');
            messageDiv.textContent = text;
        } else if (role === 'thinking') {
            messageDiv.classList.add('thinking-message');
            messageDiv.innerHTML = '<span class="dot"></span><span class="dot"></span><span class="dot"></span>';
        } else if (role === 'error') {
            messageDiv.classList.add('error-message');
            messageDiv.textContent = text;
        }
        
        if (id) messageDiv.id = id;

        chatLog.appendChild(messageDiv);
        chatLog.scrollTop = chatLog.scrollHeight;
        return messageDiv;
    }

    // Function to send data to Qualtrics
    function sendDataToQualtrics(dataObject) {
        console.log(`%c[IFRAME - Instance ${SCRIPT_INSTANCE_ID}] sendDataToQualtrics CALLED. isChatbotInitialized: ${isChatbotInitialized}, dynamicQualtricsOrigin: ${dynamicQualtricsOrigin}`, "color: blue; font-weight: bold;", "DataObject:", dataObject);
        
        if (!isChatbotInitialized || !dynamicQualtricsOrigin) {
            console.error(`[IFRAME - Instance ${SCRIPT_INSTANCE_ID}] CRITICAL: Cannot send message to Qualtrics. Conditions not met. isChatbotInitialized: ${isChatbotInitialized}, dynamicQualtricsOrigin: ${dynamicQualtricsOrigin}. Message NOT sent.`);
            // Optionally, display an error to the user in the chat UI
            // addMessageToChatLog("Error: Could not save data. Please check connection or contact support.", 'error');
            return;
        }

        if (window.parent && window.parent.postMessage) {
            try {
                const dataString = JSON.stringify(dataObject);
                console.log(`[IFRAME - Instance ${SCRIPT_INSTANCE_ID}] Attempting to send 'chatbot_data' to Qualtrics. Target Origin: ${dynamicQualtricsOrigin}. Stringified Payload: ${dataString}`);
                window.parent.postMessage({
                    type: 'chatbot_data',
                    data: dataString 
                }, dynamicQualtricsOrigin);
                console.log(`[IFRAME - Instance ${SCRIPT_INSTANCE_ID}] 'chatbot_data' message sent to parent.`);
            } catch (e) {
                console.error(`[IFRAME - Instance ${SCRIPT_INSTANCE_ID}] Error stringifying or sending data to Qualtrics:`, e, "Original dataObject:", dataObject);
            }
        } else {
            console.warn(`[IFRAME - Instance ${SCRIPT_INSTANCE_ID}] Cannot send data to Qualtrics: window.parent.postMessage is not available.`);
        }
    }

    // --- Single listener for messages from parent (Qualtrics) ---
    window.addEventListener('message', function(event) {
        console.log(`[IFRAME MSG RECV - Instance ${SCRIPT_INSTANCE_ID}] Raw message: Origin=${event.origin}, Type=${event.data ? event.data.type : 'N/A'}, Data:`, event.data);

        if (event.data && event.data.type === 'init_chatbot') {
            console.log(`[IFRAME MSG RECV - Instance ${SCRIPT_INSTANCE_ID}] 'init_chatbot' received. Message Event Origin: ${event.origin}. Config provided:`, event.data.config);
            
            // Basic validation of the config structure
            if (typeof event.data.config !== 'object' || event.data.config === null) {
                console.error(`[IFRAME - Instance ${SCRIPT_INSTANCE_ID}] CRITICAL: 'init_chatbot' received, but 'config' is not a valid object. Config:`, event.data.config);
                isChatbotInitialized = false;
                dynamicQualtricsOrigin = null;
                addMessageToChatLog("Error: Chatbot configuration is invalid. Please contact support.", 'error');
                return;
            }
            chatbotConfig = event.data.config; // Store the received config

            if (chatbotConfig.qualtricsParentOrigin && typeof chatbotConfig.qualtricsParentOrigin === 'string' && chatbotConfig.qualtricsParentOrigin.startsWith('http')) {
                dynamicQualtricsOrigin = chatbotConfig.qualtricsParentOrigin;
                isChatbotInitialized = true; // Mark this instance as initialized
                console.log(`[IFRAME - Instance ${SCRIPT_INSTANCE_ID}] 'dynamicQualtricsOrigin' SET to: ${dynamicQualtricsOrigin}. isChatbotInitialized SET to: ${isChatbotInitialized}.`);
                
                // Update UI elements from config
                const headerElement = document.querySelector('.chat-header');
                if(headerElement && chatbotConfig.uiConfig && chatbotConfig.uiConfig.headerText) {
                    headerElement.textContent = chatbotConfig.uiConfig.headerText;
                }
                if(chatInput && chatbotConfig.uiConfig && chatbotConfig.uiConfig.inputPlaceholder) {
                    chatInput.placeholder = chatbotConfig.uiConfig.inputPlaceholder;
                }
                // Add initial bot message from config if it exists and no messages are present yet
                if(chatbotConfig.initialQuestion && !chatLog.querySelector('.message')) { 
                    addMessageToChatLog(chatbotConfig.initialQuestion, 'model');
                }

                // Send config to Python backend (if applicable) - Temporarily Commented Out
                /*
                fetch('/config', { // Assuming your Flask app serves the chat.html at the root
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_id: currentSessionId, config: chatbotConfig })
                })
                .then(response => {
                    if (!response.ok) {
                        console.error(`[IFRAME - Instance ${SCRIPT_INSTANCE_ID}] Error sending config to server. Status: ${response.status}`);
                        return response.text().then(text => { throw new Error(text || 'Server error') });
                    }
                    console.log(`[IFRAME - Instance ${SCRIPT_INSTANCE_ID}] Config sent to server successfully.`);
                })
                .catch(error => console.error(`[IFRAME - Instance ${SCRIPT_INSTANCE_ID}] Error sending config to server:`, error));
                */

            } else {
                isChatbotInitialized = false; 
                dynamicQualtricsOrigin = null;
                console.error(`[IFRAME - Instance ${SCRIPT_INSTANCE_ID}] CRITICAL: 'init_chatbot' received, but 'qualtricsParentOrigin' is MISSING or INVALID in config. Config:`, chatbotConfig, `isChatbotInitialized is now ${isChatbotInitialized}.`);
                addMessageToChatLog("Error: Chatbot cannot securely connect. Missing origin configuration.", 'error');
            }
        } else if (event.data && event.data.type === 'get_chat_data') {
            console.log(`[IFRAME MSG RECV - Instance ${SCRIPT_INSTANCE_ID}] 'get_chat_data' received. Message Event Origin: ${event.origin}. Current dynamicQualtricsOrigin: ${dynamicQualtricsOrigin}. isChatbotInitialized: ${isChatbotInitialized}.`);

            if (event.origin !== dynamicQualtricsOrigin) {
                console.warn(`[IFRAME - Instance ${SCRIPT_INSTANCE_ID}] INFO: 'get_chat_data' origin ('${event.origin}') does not match dynamicQualtricsOrigin ('${dynamicQualtricsOrigin}'). This is expected if Qualtrics proxies this message (e.g., from google.qualtrics.com). Proceeding based on initialization status.`);
            }

            if (!isChatbotInitialized) {
                console.error(`[IFRAME - Instance ${SCRIPT_INSTANCE_ID}] CRITICAL: Received 'get_chat_data', but chatbot is NOT INITIALIZED (isChatbotInitialized: false). Ignoring message.`);
                addMessageToChatLog("Error: Chatbot not initialized. Cannot retrieve data. Please ensure configuration was received.", "error");
                return;
            }

            // If we reach here, chatbot is initialized. Send data.
            const messagesToSend = [];
            chatLog.querySelectorAll('.message').forEach(msgElement => {
                let role = null;
                if (msgElement.classList.contains('user-message')) role = 'user';
                else if (msgElement.classList.contains('bot-message')) role = 'model';
                
                // Only send user and model messages to represent the actual conversation
                if (role) {
                    messagesToSend.push({ role: role, parts: [msgElement.textContent || ''] });
                }
            });
            console.log(`[IFRAME - Instance ${SCRIPT_INSTANCE_ID}] History collected for 'get_chat_data':`, messagesToSend);

            // Always send a stringified object with metadata, not just the array
            const payload = {
                qid: chatbotConfig && chatbotConfig.qid ? chatbotConfig.qid : null,
                session_id: currentSessionId,
                history: messagesToSend,
                timestamp: new Date().toISOString()
            };
            sendDataToQualtrics(payload);
        } else {
            // Handle other potential messages or log them as unknown
            let messageType = event.data ? event.data.type : 'N/A';
            let origin = event.origin;
            console.warn(`[IFRAME MSG RECV - Instance ${SCRIPT_INSTANCE_ID}] Received unhandled/unknown message type '${messageType}' from origin '${origin}'. Data:`, event.data);
        }
    });

    // Inform the parent window that this iframe instance's listener is attached and ready for config
    // This is part of the handshake mechanism
    console.log(`[IFRAME SCRIPT END - Instance ${SCRIPT_INSTANCE_ID}] Listener attached. Sending 'iframe_ready_for_config' to parent. Current dynamicQualtricsOrigin: ${dynamicQualtricsOrigin}, isChatbotInitialized: ${isChatbotInitialized}`);
    // Ensure window.parent exists and postMessage is available before calling it.
    if (window.parent && typeof window.parent.postMessage === 'function') {
        window.parent.postMessage({ type: 'iframe_ready_for_config', instanceId: SCRIPT_INSTANCE_ID }, '*'); // '*' is acceptable here as parent will verify origin of this message.
    } else {
        console.error(`[IFRAME - Instance ${SCRIPT_INSTANCE_ID}] Cannot send 'iframe_ready_for_config': window.parent or window.parent.postMessage is not available.`);
        // This might happen if the iframe is not embedded or in a sandboxed environment that restricts parent access.
    }

</script>
</body>
</html>